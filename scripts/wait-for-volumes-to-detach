#!/bin/bash

set -euo pipefail

[ -v DETACHMENT_WAIT_TIMEOUT ] || DETACHMENT_WAIT_TIMEOUT=""
[ -n "${DETACHMENT_WAIT_TIMEOUT}" ] || DETACHMENT_WAIT_TIMEOUT="20m"

[ -v DISABLE_DETACHMENT_WAIT ] || DISABLE_DETACHMENT_WAIT=""
case "${DISABLE_DETACHMENT_WAIT,,}" in
	true | t | yes | y ) DISABLE_DETACHMENT_WAIT="true" ;;
	* ) DISABLE_DETACHMENT_WAIT="false" ;;
esac
export DISABLE_DETACHMENT_WAIT

timestamp()
{
	/usr/bin/date -Ins -u
}

say()
{
	echo -e "$(timestamp): ${@}"
}

ok()
{
	say "✅ ${@}"
}

warn()
{
	say "⚠️ ${@}"
}

err()
{
	say "❌ ${@}"
}

quit()
{
	say "🚪 ${@}"
	exit 0
}

fail()
{
	err "${@}"
	exit ${EXIT_CODE:-1}
}

is_valid_name()
{
	local NAME="${1}"
	[[ "${NAME}" =~ ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$ ]] || return 1
	return 0
}

execute()
{
	#
	# Show the command about to be executed
	#
	say "${@@Q}"
	if "${DISABLE_DETACHMENT_WAIT}" ; then
		warn "Attachment waiting disabled: skipping the command execution"
		return 0
	fi

	#
	# Proceed with the execution
	#
	( exec "${@}" )
	return ${?}
}

get_longhorn_volume_name()
{
	local CLUSTER="${1}"
	local PV="${2}"

	kubectl \
		--kubeconfig "${HARVESTER_CFG}" \
		--namespace "${CLUSTER}" \
		get pvc "${PV}" -o json | \
		jq -r '.spec.volumeName'
}

get_longhorn_volume_data()
{
	local CLUSTER="${1}"
	local PV="${2}"

	local VOLUME="$(get_longhorn_volume_name "${@}")"
	[ -n "${VOLUME}" ] || return 1
	kubectl \
		--kubeconfig "${HARVESTER_CFG}" \
		--namespace "${LONGHORN_NAMESPACE}" \
		get volume "${VOLUME}" -o json
}

get_release_pvs()
{
	local NAMESPACE="${1}"
	local RELEASE="${2}"

	kubectl \
		--kubeconfig "${CLUSTER_CFG}" \
		--namespace "${NAMESPACE}" \
		get pvc \
			-l "app.kubernetes.io/instance=${RELEASE}" \
			-o custom-columns="PV:.spec.volumeName" --no-headers
}

get_longhorn_volume()
{
	local CLUSTER="${1}"
	local NAMESPACE="${2}"
	local PVC="${3}"
	local PV="$(get_pv "${@}")" || return 1

	local DATA="$(get_longhorn_volume_data "${CLUSTER}" "${PV}")"
	echo "${DATA}"
}

cleanup()
{
	[ -n "${CLUSTER_CFG:-}" ] && shred -u "${CLUSTER_CFG}"
	[ -n "${HARVESTER_CFG:-}" ] && shred -u "${HARVESTER_CFG}"
}

usage()
{
	echo -e "usage: ${BASH_ARGV0:-${BASH_SOURCE:-${0}}} cluster namespace release"
	exit 1
}

[ ${#} -eq 3 ] || usage

CLUSTER="${1}"
is_valid_name "${CLUSTER}" || fail "Invalid Rancher cluster name: [${CLUSTER}]"

NAMESPACE="${2}"
is_valid_name "${NAMESPACE}" || fail "Invalid namespace: [${NAMESPACE}]"

RELEASE="${3}"
is_valid_name "${RELEASE}" || fail "Invalid release name: [${RELEASE}]"

[ -v HARVESTER ] || HARVESTER=""
[ -n "${HARVESTER}" ] || HARVESTER="harvester-ai5"
is_valid_name "${HARVESTER}" || fail "Invalid Harvester cluster name: [${HARVESTER}]"

[ -v LONGHORN_NAMESPACE ] || LONGHORN_NAMESPACE=""
[ -n "${LONGHORN_NAMESPACE}" ] || LONGHORN_NAMESPACE="longhorn-system"
is_valid_name "${LONGHORN_NAMESPACE}" || fail "Invalid Longhorn namespace: [${LONGHORN_NAMESPACE}]"

trap cleanup EXIT

CLUSTER_CFG="$(mktemp "${CLUSTER}.XXXXXXXX.conf")"
rancher-get-kubeconfig "${CLUSTER}" "${CLUSTER_CFG}" || exit ${?}
ok "Downloaded the kubeconfig for ${CLUSTER}"

HARVESTER_CFG="$(mktemp "${HARVESTER}.XXXXXXXX.conf")"
rancher-get-kubeconfig "${HARVESTER}" "${HARVESTER_CFG}" || exit ${?}
ok "Downloaded the kubeconfig for ${HARVESTER}"

#
# Step one: get the non-ephemeral PVs from the namespace
#

PVS="$(get_release_pvs "${NAMESPACE}" "${RELEASE}" 2>&1)" || fail "Failed to get the PVS at ${CLUSTER}::${NAMESPACE}, release ${RELEASE} (rc=${?}): ${PVS}"

readarray -t PVS <<< "${PVS}"

[ ${#PVS[@]} -gt 1 ] || quit "No PVs found for release ${RELEASE} at ${CLUSTER}::${NAMESPACE}"

#
# Step two: convert those PV names into Longhorn volume object names
#
VOLUMES=()
S="s"
[ ${#PVS[@]} -ne 1 ] || S=""
say "Resolving ${#PVS[@]} PersistentVolume object${S} to the underlying Longhorn Volume objects: ${PVS[@]}"
for PV in "${PVS[@]}" ; do
	if ! VOLUME="$(get_longhorn_volume_name "${CLUSTER}" "${PV}" 2>&1)" ; then
		err "Failed to get the volume name for the PV ${CLUSTER}::${PV} (rc=${?}): ${VOLUME}"
		continue
	fi

	say "\tResolved ${PV} -> ${VOLUME}"

	VOLUMES+=( "${VOLUME}" )
done

[ ${#VOLUMES[@]} -gt 1 ] || quit "No Volume objects could be resolved"

#
# Step three: begin the wait on those Longhorn volumes to detach
#
S="s"
[ ${#VOLUMES[@]} -ne 1 ] || S=""
say "Waiting for the above ${#VOLUMES[@]} volume${S} to become detached..."
execute kubectl \
	--kubeconfig "${HARVESTER_CFG}" \
	--namespace "${LONGHORN_NAMESPACE}" \
	wait volume "${VOLUMES[@]}" \
	--for jsonpath=".status.state=detached" \
	--timeout "${DETACHMENT_WAIT_TIMEOUT}"
