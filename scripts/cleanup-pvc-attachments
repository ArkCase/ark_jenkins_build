#!/bin/bash

set -euo pipefail

ATTACHMENT_RESOURCE="volumeattachments.storage.k8s.io"

[ -v CLEANUP_TIMEOUT ] || CLEANUP_TIMEOUT=""
[ -n "${CLEANUP_TIMEOUT}" ] || CLEANUP_TIMEOUT="1m"

[ -v CLEANUP_KILL_DELAY ] || CLEANUP_KILL_DELAY=""
[ -n "${CLEANUP_KILL_DELAY}" ] || CLEANUP_KILL_DELAY="5s"

[ -v DISABLE_CLEANUP ] || DISABLE_CLEANUP=""
case "${DISABLE_CLEANUP,,}" in
	true | t | yes | y ) DISABLE_CLEANUP="true" ;;
	* ) DISABLE_CLEANUP="false" ;;
esac
export DISABLE_CLEANUP

[ -v CLEANUP_ALL ] || CLEANUP_ALL=""
case "${CLEANUP_ALL,,}" in
	true | t | yes | y | on | en | enable | enabled | active ) CLEANUP_ALL="true" ;;
	* ) CLEANUP_ALL="false" ;;
esac

[ -v CLEANUP_FORCE ] || CLEANUP_FORCE=""
case "${CLEANUP_FORCE,,}" in
	true | t | yes | y | on | en | enable | enabled | active ) CLEANUP_FORCE="true" ;;
	* ) CLEANUP_FORCE="false" ;;
esac

timestamp()
{
	date -Ins -u
}

say()
{
	echo -e "$(timestamp): ${@}"
}

ok()
{
	say "‚úÖ ${@}"
}

warn()
{
	say "‚ö†Ô∏è ${@}"
}

err()
{
	say "‚ùå ${@}"
}

fail()
{
	err "${@}"
	exit ${EXIT_CODE:-1}
}

is_valid_name()
{
	local NAME="${1}"
	[[ "${NAME}" =~ ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$ ]] || return 1
	return 0
}

execute()
{
	#
	# Show the command about to be executed
	#
	say "${@@Q}"
	if "${DISABLE_CLEANUP}" ; then
		warn "Cleanup disabled: skipping the command execution"
		return 0
	fi

	#
	# Proceed with the execution
	#
	( exec "${@}" )
	return ${?}
}

#
# This function returns the number that serves as
# a multiplier/divisor for a given time scale
#
get_time_mul()
{
	local TAG="${1^^}"

	[[ "${TAG}" =~ ^[HDMS]$ ]] || return 1
	local DURATION_S=1
	local DURATION_M=$(( DURATION_S * 60 ))
	local DURATION_H=$(( DURATION_M * 60 ))
	local DURATION_D=$(( DURATION_H * 24 ))

	local VAR="DURATION_${TAG}"
	echo -n "${!VAR}"
}

#
# This function converts numbers of seconds into
# K8s timespecs, but leaves timespec strings alone
#
secs_to_timestr()
{
	local STR="${1}"
	local NUM="(0|[1-9][0-9]*)"

	[ -n "${STR}" ] || return 1

	# If it's already a time string, return it
	if [[ "${STR^^}" =~ ^(${NUM}D)?(${NUM}H)?(${NUM}M)?(${NUM}S)?$ ]] ; then
		echo -n "${STR,,}"
		return 0
	fi

	[[ "${STR}" =~ ^${NUM}$ ]] || return 1

	local RET=""
	local SIZE=0
	local MUL=0
	local SECS=${STR}
	for C in D H M S ; do
		MUL=$(get_time_mul "${C}")
		(( SIZE = ( SECS / MUL ) ))
		[ ${SIZE} -gt 0 ] && RET+="${SIZE}${C}"
		(( SECS -= ( SIZE * MUL ) ))
	done

	echo -n ${RET,,}
	return 0
}

#
# This function converts K8s timespecs into
# numbers of seconds, but leaves numbers alone
#
timestr_to_secs()
{
	local STR="${1}"
	local NUM="(0|[1-9][0-9]*)"

	# If it's a straight-up number,
	# seconds already, so just return it
	if [[ "${STR}" =~ ^${NUM}$ ]] ; then
		echo -e "${STR}"
		return 0
	fi

	# It could be a time string, so parse it out
	[ -n "${STR}" ] || return 1
	[[ "${STR^^}" =~ ^(${NUM}D)?(${NUM}H)?(${NUM}M)?(${NUM}S)?$ ]] || return 1

	local PARTS=( "${BASH_REMATCH[@]:1}" )
	[ ${#PARTS[@]} -ge 1 ] || return 1

	local SIZE=0
	local MUL=0
	local SECS=0
	for (( i = 0 ; i < ${#PARTS[@]} ; i++ )) ; do
		[[ "${PARTS[i]}" =~ ^${NUM}([DHMS])$ ]] || continue
		SIZE=${BASH_REMATCH[1]}
		MUL=$(get_time_mul "${BASH_REMATCH[2]}")
		(( SECS += SIZE * MUL ))
	done

	echo -n ${SECS}
	return 0
}

is_attachment_valid()
{
	local ATTACHMENT="${1}"
	local ATTACHMENT_INFO="${2}"

	# Identify the node and PV that it's attached to
	local PV="$(jq -r ".spec.source.persistentVolumeName" <<< "${ATTACHMENT_INFO}")"
	local PV_INFO="$(jq -r ".items[] | select(.metadata.name == \"${PV}\")" <<< "${PV_ALL}")"

	if [ -z "${PV_INFO}" ] ; then
		say "\t‚ùå ${ATTACHMENT} üîó PV ${PV} is missing"
		return 1
	fi

	local NODE="$(jq -r ".spec.nodeName" <<< "${ATTACHMENT_INFO}")"
	local NODE_INFO="$(jq -r ".items[] | select(.metadata.name == \"${NODE}\")" <<< "${NODE_ALL}")"

	if [ -z "${NODE_INFO}" ] ; then
		say "\t‚ùå ${ATTACHMENT} üîó Node ${NODE} is missing"
		return 1
	fi

	read STATUS REST < <(jq -r '(.status.attached | tostring)' <<< "${ATTACHMENT_INFO}")
	if [ -n "${STATUS}" ] ; then
		say "\t‚úÖ ${ATTACHMENT} üîó ${NODE}"
	else
		say "\t‚úÖ the attachment [${ATTACHMENT}] is not attached"
	fi
	return 0
}

CLEANUP_TIMEOUT=$(timestr_to_secs "${CLEANUP_TIMEOUT}") || fail "Invalid value for CLEANUP_TIMEOUT: [${CLEANUP_TIMEOUT}]"
CLEANUP_KILL_DELAY=$(timestr_to_secs "${CLEANUP_KILL_DELAY}") || fail "Invalid value for CLEANUP_KILL_DELAY: [${CLEANUP_KILL_DELAY}]"

say "üëâ Fetching all the Volume Attachment data on the cluster..."
ATTACHMENT_ALL="$(kubectl get "${ATTACHMENT_RESOURCE}" -o json)"
say "üëâ Fetching all the PV data on cluster..."
PV_ALL="$(kubectl get pv -o json)"
say "üëâ Fetching all the Node data on the cluster..."
NODE_ALL="$(kubectl get node -o json)"

ATTACHMENT_COUNT="$(jq -r ".items | length" <<< "${ATTACHMENT_ALL}")"

ok "Found ${ATTACHMENT_COUNT} instances of ${ATTACHMENT_RESOURCE}"
[ ${ATTACHMENT_COUNT} -gt 0 ] || exit 0

readarray -t ATTACHMENTS < <(jq -r ".items[] | .metadata.name" <<< "${ATTACHMENT_ALL}" | sort -u)

TARGETS=()
for ATTACHMENT in "${ATTACHMENTS[@]}" ; do
	ATTACHMENT_INFO="$(jq -r ".items[] | select(.metadata.name == \"${ATTACHMENT}\")" <<< "${ATTACHMENT_ALL}")"

	is_attachment_valid "${ATTACHMENT}" "${ATTACHMENT_INFO}" && continue

	TARGETS+=("${PV}/${ATTACHMENT}/${NODE}")
done

if [ ${#TARGETS[@]} -eq 0 ] ; then
	ok "No attachments needed deletion!"
	exit 0
fi

if "${CLEANUP_FORCE}" ; then
	warn "Forced deletion is activated! Will use --force when deleting resources"
	CLEANUP_FORCE=(--force)
else
	CLEANUP_FORCE=()
fi
say "üëâ Found ${#TARGETS[@]} attachments that needed deleting..."
echo "${TARGETS[@]}" | tr ' ' '\n'
exit 0
for INFO in "${TARGETS[@]}" ; do
	IFS="/" read PV ATTACHMENT NODE <<< "${INFO}"
	say "üëÄ ${PV} üîó ${ATTACHMENT} üîó ${NODE}"
	continue

	RC=0
	execute timeout -k ${CLEANUP_KILL_DELAY} ${CLEANUP_TIMEOUT} kubectl delete --ignore-not-found=true --grace-period=1 --wait=true "${CLEANUP_FORCE[@]}" "${ATTACHMENT_RESOURCE}" "${ATTACHMENT}" || RC=${?}
	if [ ${RC} -eq 0 ] ; then
		ok "Attachment deleted!"
	else
		case "${RC}" in
			124 )	say "\t‚åõ Deletion request timed out" ;;
			* )		say "\t‚ùå Deletion failed (${RC})" ;;
		esac
	fi
done
exit 0
