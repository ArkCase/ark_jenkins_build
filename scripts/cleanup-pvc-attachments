#!/bin/bash

set -euo pipefail

ATTACHMENT_RESOURCE="volumeattachments.storage.k8s.io"

[ -v CLEANUP_TIMEOUT ] || CLEANUP_TIMEOUT=""
[ -n "${CLEANUP_TIMEOUT}" ] || CLEANUP_TIMEOUT="5m"

[ -v FORCE_DELETE ] || FORCE_DELETE=""
case "${FORCE_DELETE,,}" in
	true | t | yes | y | on | en | enable | enabled | active ) FORCE_DELETE="true" ;;
	* ) FORCE_DELETE="false" ;;
esac

timestamp()
{
	/usr/bin/date -Ins
}

say()
{
	echo -e "$(timestamp): ${@}"
}

ok()
{
	say "‚úÖ ${@}"
}

warn()
{
	say "‚ö†Ô∏è ${@}"
}

err()
{
	say "‚ùå ${@}" 1>&2
}

fail()
{
	err "${@}"
	exit ${EXIT_CODE:-1}
}

is_valid_name()
{
	local NAME="${1}"
	[[ "${NAME}" =~ ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$ ]] || return 1
	return 0
}

is_attachment_valid()
{
	local ATTACHMENT_INFO="${1}"

	local ATTACHED=""
	local NODE=""

	read ATTACHED NODE < <("${JQ}" -r '(.status.attached | tostring) + " " + .spec.nodeName' <<< "${ATTACHMENT_INFO}")
	if [ -z "${ATTACHED}" ] || [ -z "${NODE}" ] ; then
		# No node info?!?
		say "\t‚ùå the attachment [${ATTACHMENT}] has no node information... deleting"
		return 1
	fi

	# TODO: Validate that the node exists....
	if ! "${KUBECTL}" get node "${NODE}" &>/dev/null ; then
		say "\t‚ùå ${ATTACHMENT} -> ${NODE} is missing"
		return 1
	fi

	# Node is OK ... do we want to try to hunt down the pod(s) that it's attached to?
	# If those pods are down, perhaps this attachment can be deleted?
	say "\t‚úÖ ${ATTACHMENT} üîó ${NODE}"
	return 0
}

usage()
{
	echo -e "usage: ${BASH_ARGV0:-${BASH_SOURCE:-${0}}} [namespace] release"
	exit 1
}

KUBECTL="$(type -P kubectl)" || fail "Could not find 'kubectl' in the path"
EGREP="$(type -P egrep)" || fail "Could not find 'egrep' in the path"
JQ="$(type -P jq)" || fail "Could not find 'jq' in the path"
AWK="$(type -P awk)" || fail "Could not find 'awk' in the path"
SED="$(type -P sed)" || fail "Could not find 'sed' in the path"
SORT="$(type -P sort)" || fail "Could not find 'sort' in the path"
TIMEOUT="$(type -P timeout)" || fail "Could not find 'timeout' in the path"

[ ${#} -ge 1 ] && [ ${#} -le 2 ] || usage

if [ ${#} -eq 2 ] ; then
	NAMESPACE="${1}"
	shift
elif [ ! -v NAMESPACE ] ; then
	NAMESPACE="$("${KUBECTL}" config view --minify -o jsonpath="{..namespace}")"
	[ -n "${NAMESPACE}" ] || NAMESPACE="default"
fi
is_valid_name "${NAMESPACE}" || fail "The NAMESPACE value [${NAMESPACE}] is not valid"

RELEASE="${1}"
is_valid_name "${RELEASE}" || fail "The RELEASE value [${RELEASE}] is not valid"

"${KUBECTL}" get namespace "${NAMESPACE}" &>/dev/null || fail "The namespace [${NAMESPACE}] does not exist"

# Get all the PVCs in the currently default namespace
say "üëâ Fetching all the PVC data on the namespace ${NAMESPACE} for release ${RELEASE}..."
PVC_DATA="$("${KUBECTL}" get --namespace "${NAMESPACE}" pvc --selector="app.kubernetes.io/instance=${RELEASE}" -o json)"
PVC_COUNT="$("${JQ}" -r ".items | length" <<< "${PVC_DATA}")"

ok "Found ${PVC_COUNT} PVCs"
[ ${PVC_COUNT} -gt 0 ] || exit 0

readarray -t PVCS < <("${JQ}" -r ".items[] | .metadata.name" <<< "${PVC_DATA}" | "${SORT}" -u)

ATTACHMENT_DATA="$("${KUBECTL}" get "${ATTACHMENT_RESOURCE}" -o json)"

DELETIONS=()
"${FORCE_DELETE}" && warn "Forced deletion is activated! All attachments found will be deleted!"
for PVC in "${PVCS[@]}" ; do

	if ! is_valid_name "${PVC}" ; then
		err "PVC name [${PVC}] is not valid"
		continue
	fi

	say "Scanning the for attachments to PVC ${PVC}..."

	PV="$("${JQ}" -r ".items[] | select(.metadata.name == \"${PVC}\") | .spec.volumeName" <<< "${PVC_DATA}")"
	if [ -z "${PV}" ] || ! "${KUBECTL}" get pv "${PV}" &>/dev/null ; then
		err "No volume ${PV} found ... referenced by PVC ${PVC}"
		continue
	fi

	# For each PVC, identify the pod(s) it's attached to
	readarray -t ATTACHMENTS < <("${JQ}" -r ".items[] | select(.spec.source.persistentVolumeName == \"${PV}\") | .metadata.name" <<< "${ATTACHMENT_DATA}")

	say "${PVC} - ${#ATTACHMENTS[@]} attachments found"
	[ "${#ATTACHMENTS[@]}" -ge 1 ] || continue

	for ATTACHMENT in "${ATTACHMENTS[@]}" ; do
		ATTACHMENT_INFO="$("${JQ}" -r ".items[] | select(.metadata.name == \"${ATTACHMENT}\")" <<< "${ATTACHMENT_DATA}")"

		if ! "${FORCE_DELETE}" ; then
			is_attachment_valid "${ATTACHMENT_INFO}" && continue
		fi

		NODE="$("${JQ}" -r '.spec.nodeName' <<< "${ATTACHMENT_INFO}")"

		DELETIONS+=("${PVC}/${PV}/${ATTACHMENT}/${NODE}")
	done
done

if [ ${#DELETIONS[@]} -eq 0 ] ; then
	ok "No attachments needed deletion!"
	exit 0
fi

say "üëâ Found ${#DELETIONS[@]} attachments that needed deleting..."
ARGS=()
for INFO in "${DELETIONS[@]}" ; do
	IFS="/" read PVC PV ATTACHMENT NODE <<< "${INFO}"
	say "\t${PVC} -> ${PV} -> ${ATTACHMENT} -> ${NODE}"
	ARGS+=("${ATTACHMENT}")
done

RC=0
"${KUBECTL}" delete "${ATTACHMENT_RESOURCE}" --timeout="${CLEANUP_TIMEOUT}" "${ARGS[@]}" || RC=${?}
if [ ${RC} -ne 0 ] ; then
	# TODO: should we go back to using timeout to show the nicer timeout message?
	case "${RC}" in
		124 )	say "\t‚åõ Deletion request timed out" ;;
		* )		say "\t‚ùå Deletion failed (${RC})" ;;
	esac
fi
exit ${RC}
