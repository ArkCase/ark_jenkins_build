#!/bin/bash
SCRIPT="$(/usr/bin/readlink -f "${BASH_SOURCE:-${0}}")"
BASEDIR="$(/usr/bin/dirname "${SCRIPT}")"

set -euo pipefail

[ -v DEPLOY_TIMEOUT ] || DEPLOY_TIMEOUT=""
[ -n "${DEPLOY_TIMEOUT}" ] || DEPLOY_TIMEOUT="20m"

[ -v DISABLE_DEPLOY ] || DISABLE_DEPLOY=""
case "${DISABLE_DEPLOY,,}" in
	true | t | yes | y ) DISABLE_DEPLOY="true" ;;
	* ) DISABLE_DEPLOY="false" ;;
esac
export DISABLE_DEPLOY

timestamp()
{
	/usr/bin/date -Ins -u
}

say()
{
	echo -e "$(timestamp): ${@}"
}

warn()
{
	say "⚠️ ${@}"
}

err()
{
	say "❌ ${@}" 1>&2
}

fail()
{
	err "${@}"
	exit ${EXIT_CODE:-1}
}

is_valid_name()
{
	local STR="${1}"
	[[ "${STR}" =~ ^[a-z0-9]([a-z0-9-]*[a-z0-9])?$ ]] || return 1
	return 0
}

execute()
{
	#
	# Show the command about to be executed
	#
	say "${@@Q}"
	if "${DISABLE_DEPLOY}" ; then
		warn "Deployment disabled: skipping the command execution"
		return 0
	fi

	#
	# Proceed with the execution
	#
	( exec "${@}" )
	return ${?}
}

ensure_namespace_exists()
{
	local NAMESPACE="${1}"
	execute "${KUBECTL}" get namespace "${NAMESPACE}" &>/dev/null && return 0
	execute "${KUBECTL}" create namespace "${NAMESPACE}" && return 0
	return 1
}

sanitize_paths()
{
	local STR="${1}"
	local SEP=":"
	local PARTS=()

	# First, split into parts so we can retain the
	# declaration order
	readarray -t PARTS < <(/usr/bin/tr "${SEP}" "\n" <<< "${STR}" | /usr/bin/sed -e '/^\s*$/d')
	local LIST=":"
	for P in "${PARTS[@]}" ; do
		[ -n "${P}" ] || continue
		# Skip it if already marked
		/usr/bin/fgrep -q ":${P}:" <<< "${LIST}" && continue
		LIST+="${P}:"
		echo "${P}"
	done
}

sanitize_common_dirs()
{
	local COMMON_DIRS=()
	# We split this in two so it's easy to lift the sanitize_paths function for other purposes
	readarray -t COMMON_DIRS < <(sanitize_paths "${1}")
	for C in "${COMMON_DIRS[@]}" ; do
		[[ "${C}" =~ ^(/*)(.*)$ ]] && C="${BASH_REMATCH[2]}"
		if [[ "${C}" =~ (^|/)[.]{1,2}(/|$) ]] ; then
			warn "Skipping the common directory specification [${C}]: may not contain '.' or '..' as path components"
			continue
		fi
		echo "${C}"
	done
}

usage()
{
	echo -e "usage: ${BASH_SOURCE:-${0}} [namespace] release chart environment [--helm extraHelmArgs...]" 1>&2
	exit 1
}

BASE_ARGS=()
for a in "${@}" ; do
	case "${a}" in
		--helm ) shift ; break ;;
		* ) BASE_ARGS+=("${a}") ; shift ;;
	esac
done
HELM_ARGS=("${@}")

set -- "${BASE_ARGS[@]}"

[ ${#} -ge 3 ] && [ ${#} -le 4 ] || usage

HELM="$(type -P helm)" || fail "Failed to find helm in the path"
KUBECTL="$(type -P kubectl)" || fail "Failed to find kubectl in the path"

if [ "${#}" -eq 3 ] ; then
	NAMESPACE="$("${KUBECTL}" config view --minify -o jsonpath="{..namespace}")"
	[ -n "${NAMESPACE}" ] || NAMESPACE="default"
else
	NAMESPACE="${1}"
	shift
fi
is_valid_name "${NAMESPACE}" || fail "Invalid namespace name [${NAMESPACE}]"

#
# The name of the helm release to deploy
#
RELEASE="${1}"
is_valid_name "${RELEASE}" || fail "Invalid release name [${RELEASE}]"

#
# The name of the helm chart to deploy
#
CHART="${2}"
[ -n "${CHART}" ] || fail "The chart name may not be the empty string"

#
# Ensure we got the right environment n ame
#
ENVIRONMENT_NAME="${3}"
is_valid_name "${ENVIRONMENT_NAME}" || fail "Invalid environment name [${ENVIRONMENT_NAME}]"

[ -v DEPLOYMENT_DIR ] || DEPLOYMENT_DIR=""
[ -n "${DEPLOYMENT_DIR}" ] || DEPLOYMENT_DIR="${PWD}"
DEPLOYMENT_DIR="$(/usr/bin/readlink -f "${DEPLOYMENT_DIR}")" || fail "Failed to canonicalize the path for [${DEPLOYMENT_DIR}]"

say "Deploying from [${DEPLOYMENT_DIR}]..."
[ -f "${DEPLOYMENT_DIR}/deployment.yaml" ] || fail "This does not seem to be a deployment directory - no deployment.yaml was found!"

#
# This will hold the list of Helm "-f" parameters to include
# every single values file that needs to be taken into account
# for this deployment
#
VALUES=()

#
# Step one: find the common files
#
#
# The directory where the common files (i.e. files shared across
# directories) are stored.
#
[ -v COMMON_DIRS ] || COMMON_DIRS="common"
readarray -t COMMON_DIRS < <(sanitize_common_dirs "${COMMON_DIRS}")
for D in "${COMMON_DIRS[@]}" ; do
	COMMON_DIR="${DEPLOYMENT_DIR}/${D}"
	if [ -d "${COMMON_DIR}" ] ; then
		while read V ; do
			VALUES+=(-f "${V}")
		done < <(/usr/bin/find "${COMMON_DIR}" -type f -iname '*.yaml' | /usr/bin/sort -u)
	else
		warn "No common values are being applied from [${COMMON_DIR}] - the directory doesn't exist"
	fi
done

#
# Step two: find the files in the environment's directory
#
#
# The root directory where the environment directories
# are housed. The directory name must match the name
# of the environment being deployed *EXACTLY*
#
ENV_DIR="${DEPLOYMENT_DIR}/envs/${ENVIRONMENT_NAME}"

if [ -d "${ENV_DIR}" ] ; then
	while read V ; do
		VALUES+=(-f "${V}")
	done < <(/usr/bin/find "${ENV_DIR}" -type f -iname '*.yaml' | /usr/bin/sort -u)
else
	warn "No environment folder found at [${DEPLOYMENT_DIR}] for [${ENVIRONMENT_NAME}]"
fi

ensure_namespace_exists "${NAMESPACE}" || fail "Failed to ensure that the required namespace ${NAMESPACE} exists"

# Delete the old installation, since it's the safest bet to ensure
# that the correct resources, containers, and deployments are used
#
# Propagate the "disable" flag, to do nothing if we're testing
DISABLE_UNDEPLOY="${DISABLE_DEPLOY}" "${BASEDIR}/undeploy-environment" "${NAMESPACE}" "${RELEASE}" || exit ${?}

set -- "${HELM_ARGS[@]}"

# Execute the new installation, using install --replace
# because we intend to be preserving history from our
# uninstalls
RC=0
execute \
	"${HELM}" install --replace \
		"${RELEASE}" "${CHART}" \
		--namespace "${NAMESPACE}" \
		--wait \
		--timeout "${DEPLOY_TIMEOUT}" \
		"${VALUES[@]}" \
		"${@}" || RC=${?}

# If all is well... exit!
[ ${RC} -eq 0 ] && exit 0

# Something went wrong, try to offer up more information
err "The Helm deployment has failed, please review the logs"
execute "${KUBECTL}" --namespace "${NAMESPACE}" get pods
exit ${RC}
