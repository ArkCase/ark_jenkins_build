#!/bin/bash
SCRIPT="$(/usr/bin/readlink -f "${BASH_SOURCE:-${0}}")"
BASEDIR="$(/usr/bin/dirname "${SCRIPT}")"

set -euo pipefail

[ -v DEPLOY_TIMEOUT ] || DEPLOY_TIMEOUT=""
[ -n "${DEPLOY_TIMEOUT}" ] || DEPLOY_TIMEOUT="20m"

[ -v DISABLE_DEPLOY ] || DISABLE_DEPLOY=""
case "${DISABLE_DEPLOY,,}" in
	true | t | yes | y ) DISABLE_DEPLOY="true" ;;
	* ) DISABLE_DEPLOY="false" ;;
esac
export DISABLE_DEPLOY

timestamp()
{
	/usr/bin/date -Ins -u
}

say()
{
	echo -e "$(timestamp): ${@}"
}

warn()
{
	say "⚠️ ${@}"
}

err()
{
	say "❌ ${@}" 1>&2
}

fail()
{
	err "${@}"
	exit ${EXIT_CODE:-1}
}

is_deployed()
{
	local NAMESPACE="${1}"
	local RELEASE="${2}"
	"${HELM}" get --namespace "${NAMESPACE}" all "${RELEASE}" &>/dev/null
	return ${?}
}

is_valid_name()
{
	local STR="${1}"
	[[ "${STR}" =~ ^[a-z0-9]([a-z0-9-]*[a-z0-9])?$ ]] || return 1
	return 0
}

is_deployment_disabled()
{
	"${DISABLE_DEPLOY}" && return 0
	return 1
}

execute()
{
	#
	# Show the command about to be executed
	#
	say "${@@Q}"
	if is_deployment_disabled ; then
		warn "Deployment disabled: skipping the command execution"
		return 0
	fi

	#
	# Proceed with the execution
	#
	( exec "${@}" )
	return ${?}
}

ensure_namespace_exists()
{
	local NAMESPACE="${1}"
	execute "${KUBECTL}" get namespace "${NAMESPACE}" &>/dev/null && return 0
	execute "${KUBECTL}" create namespace "${NAMESPACE}" && return 0
	return 1
}

sanitize_paths()
{
	local STR="${1}"
	local SEP=":"
	local PARTS=()

	# First, split into parts so we can retain the
	# declaration order
	readarray -t PARTS < <(/usr/bin/tr "${SEP}" "\n" <<< "${STR}" | /usr/bin/sed -e '/^\s*$/d')
	local LIST=":"
	for P in "${PARTS[@]}" ; do
		[ -n "${P}" ] || continue
		# Skip it if already marked
		/usr/bin/fgrep -q ":${P}:" <<< "${LIST}" && continue
		LIST+="${P}:"
		echo "${P}"
	done
}

sanitize_common_dirs()
{
	local COMMON_DIRS=()
	# We split this in two so it's easy to lift the sanitize_paths function for other purposes
	readarray -t COMMON_DIRS < <(sanitize_paths "${1}")
	for C in "${COMMON_DIRS[@]}" ; do
		[[ "${C}" =~ ^(/*)(.*)$ ]] && C="${BASH_REMATCH[2]}"
		if [[ "${C}" =~ (^|/)[.]{1,2}(/|$) ]] ; then
			warn "Skipping the common directory specification [${C}]: may not contain '.' or '..' as path components"
			continue
		fi
		echo "${C}"
	done
}

add_namespace_to_project()
{
	local NAMESPACE="${1}"
	local CLUSTER_NAME="${2}"
	local PROJECT_NAME="${3}"

	[ -n "${CLUSTER_NAME}" ] || return 0
	[ -n "${PROJECT_NAME}" ] || return 0

	if is_deployment_disabled ; then
		warn "Deployment disabled: the namespace would have been added to the project ${CLUSTER_NAME}:${PROJECT_NAME}"
		return 0
	fi

	#
	# If the patch approach continues to not work, we can
	# substitute all the below code with this single script invocation
	#
	# "${BASEDIR}/rancher-add-ns-to-project" "${NAMESPACE}" "${CLUSTER_NAME}" "${PROJECT_NAME}"

	#
	# Parse the output
	#
	local PROJECT_INFO="$("${BASEDIR}/rancher-get-project-id" "${CLUSTER_NAME}" "${PROJECT_NAME}")" || return ${?}
	[[ "${PROJECT_INFO}" =~ ^(c-[^/]+)/(p-.*)$ ]] || fail "Invalid project information for ${CLUSTER_NAME}/${PROJECT_NAME}: [${PROJECT_INFO}]"

	local CLUSTER_ID="${BASH_REMATCH[1]}"
	is_valid_name "${CLUSTER_ID}" || fail "Invalid cluster ID for ${CLUSTER_NAME}: [${CLUSTER_ID}]"

	local PROJECT_ID="${BASH_REMATCH[2]}"
	is_valid_name "${PROJECT_ID}" || fail "Invalid project ID for ${PROJECT_NAME}: [${PROJECT_ID}]"

	#
	# We're good to go!
	#
	"${KUBECTL}" patch namespace "${NAMESPACE}" --patch-file /dev/stdin <<-EOF
	{
		"metadata": {
			"annotations": {
				"field.cattle.io/projectId": "${CLUSTER_ID}:${PROJECT_ID}",
				"lifecycle.cattle.io/create.namespace-auth": "true"
			},
			"name": "${NAMESPACE}"
		}
	}
	EOF

	return ${?}
}

usage()
{
	echo -e "usage: ${BASH_SOURCE:-${0}} chart environment [extraHelmArgs...]" 1>&2
	exit 1
}

[ ${#} -ge 2 ] || usage

HELM="$(type -P helm)" || fail "Failed to find helm in the path"
KUBECTL="$(type -P kubectl)" || fail "Failed to find kubectl in the path"

if [ ! -v KUBECONFIG ] ; then
	[ -v K8S_CONFIG ] && export KUBECONFIG="${!K8S_CONFIG}"
fi

[ -v NAMESPACE ] || NAMESPACE=""
[ -n "${NAMESPACE}" ] || NAMESPACE="$("${KUBECTL}" config view --minify -o jsonpath="{..namespace}")"
is_valid_name "${NAMESPACE}" || fail "Invalid namespace name [${NAMESPACE}]"

[ -v RELEASE ] || RELEASE=""
[ -n "${RELEASE}" ] || RELEASE="arkcase"
is_valid_name "${RELEASE}" || fail "Invalid release name [${RELEASE}]"

[ -v BASE_DIR ] || BASE_DIR=""
[ -n "${BASE_DIR}" ] || BASE_DIR="${PWD}"
BASE_DIR="$(/usr/bin/readlink -f "${BASE_DIR}")" || fail "Failed to canonicalize the path for [${BASE_DIR}]"

#
# The name of the helm chart to deploy
#
CHART="${1}"
[ -n "${CHART}" ] || fail "The chart name may not be the empty string"
shift

#
# Ensure we got the right environment n ame
#
ENVIRONMENT_NAME="${1}"
[ -n "${ENVIRONMENT_NAME}" ] || fail "The environment name may not be the empty string"
is_valid_name "${ENVIRONMENT_NAME}" || fail "Invalid environment name [${ENVIRONMENT_NAME}]"
shift

#
# This information is useful because it will enable us to
# manage permissions automatically and programmatically,
# instead of doing something else
#
[ -v RANCHER_PROJECT_INFO ] || RANCHER_PROJECT_INFO=""
if [[ "${RANCHER_PROJECT_INFO}" =~ ^(.+)/(.+)$ ]] ; then
	# Add the annotations to the existing namespace
	CLUSTER_NAME="${BASH_REMATCH[1]}"
	PROJECT_NAME="${BASH_REMATCH[2]}"
else
	warn "No valid rancher project info, so will not take it into account (${RANCHER_PROJECT_INFO:-<empty string>})"
	CLUSTER_NAME=""
	PROJECT_NAME=""
fi

#
# This will hold the list of Helm "-f" parameters to include
# every single values file that needs to be taken into account
# for this deployment
#
VALUES=()

#
# Step one: find the common files
#
#
# The directory where the common files (i.e. files shared across
# directories) are stored.
#
[ -v COMMON_DIRS ] || COMMON_DIRS="common"
readarray -t COMMON_DIRS < <(sanitize_common_dirs "${COMMON_DIRS}")
for D in "${COMMON_DIRS[@]}" ; do
	COMMON_DIR="${BASE_DIR}/${D}"
	if [ -d "${COMMON_DIR}" ] ; then
		while read V ; do
			VALUES+=(-f "${V}")
		done < <(/usr/bin/find "${COMMON_DIR}" -type f -iname '*.yaml' | /usr/bin/sort -u)
	else
		warn "No common values are being applied from [${COMMON_DIR}] - the directory doesn't exist"
	fi
done

#
# Step two: find the files in the environment's directory
#
#
# The root directory where the environment directories
# are housed. The directory name must match the name
# of the environment being deployed *EXACTLY*
#
ENV_DIR="${BASE_DIR}/envs/${ENVIRONMENT_NAME}"

if [ -d "${ENV_DIR}" ] ; then
	while read V ; do
		VALUES+=(-f "${V}")
	done < <(/usr/bin/find "${ENV_DIR}" -type f -iname '*.yaml' | /usr/bin/sort -u)
else
	warn "No environment folder found at [${BASE_DIR}] for [${ENVIRONMENT_NAME}]"
fi

ensure_namespace_exists "${NAMESPACE}" || fail "Failed to ensure that the required namespace ${NAMESPACE} exists"
add_namespace_to_project "${NAMESPACE}" "${CLUSTER_NAME}" "${PROJECT_NAME}" || fail "Failed to apply the project information (${CLUSTER_NAME}:${PROJECT_NAME}) to the namespace ${NAMESPACE}"

# Delete the old installation, since it's the safest bet to ensure
# that the correct resources, containers, and deployments are used
"${BASEDIR}/undeploy-environment" "${NAMESPACE}" "${RELEASE}" || exit ${?}

# Execute the new installation (we use upgrade b/c we want to future
# proof this for when we actually do in-place upgrades)
RC=0
execute \
	"${HELM}" upgrade --install "${RELEASE}" "${CHART}" \
		--namespace "${NAMESPACE}" \
		--wait \
		--timeout "${DEPLOY_TIMEOUT}" \
		"${VALUES[@]}" \
		"${@}" || RC=${?}

# If all is well... exit!
[ ${RC} -eq 0 ] && exit 0

# Something went wrong, try to offer up more information
err "The Helm deployment has failed, please review the logs"
"${KUBECTL}" --namespace "${NAMESPACE}" get pods
exit ${RC}
